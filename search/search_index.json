{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"DEVSE wiki english translation This is a forked version of https://github.com/developpement-systeme-exploitation/documentation to add english This guide is available at caelwithcats.github.io/devse-documentation-en . Licence The original license This work is made available under the terms of the Creative Commons Attribution 2.0 France License . The tree structure x86_64 This section is dedicated to 64 bit support for the x86 architecture. ARM This section is dedicated to everything related to the ARM architecture (empty for now).","title":"DEVSE wiki english translation"},{"location":"#devse-wiki-english-translation","text":"This is a forked version of https://github.com/developpement-systeme-exploitation/documentation to add english This guide is available at caelwithcats.github.io/devse-documentation-en .","title":"DEVSE wiki english translation"},{"location":"#licence","text":"The original license This work is made available under the terms of the Creative Commons Attribution 2.0 France License .","title":"Licence"},{"location":"#the-tree-structure","text":"","title":"The tree structure"},{"location":"#x86_64","text":"This section is dedicated to 64 bit support for the x86 architecture.","title":"x86_64"},{"location":"#arm","text":"This section is dedicated to everything related to the ARM architecture (empty for now).","title":"ARM"},{"location":"CONTRIBUER/","text":"Contribuer au wiki Avant toute contribution, la lecture de ce domument est obligatoire. Evitez de faire des fautes d'orthographes. Nous utilisons comme langage principal le C ou le C++. Merci de ne pas copier-coller d'autres articles. Nous refusons le 32bit car ce n'est plus d'actualit\u00e9. La structure suivante est de rigueur pour l'ensemble des documents : En haut du document, vous retrouvez des liens / une table qui regroupe toute les parties du document, Vous retrouverez ensuite si n\u00e9c\u00e9ssaire les parties \u00e0 configurer, Vous retrouverez pour finir le contenu du document. A la fin, vous devez rajouter votre pseudo github comme ceci : ### R\u00e9gid\u00e9 par [pseudo du cr\u00e9ateur], contribution.s par [pseudos des contributeurs] Commits / Pull requests Vous devez suivre les r\u00e8gles suivantes pour la r\u00e9daction des noms de commits / pull requests. type de la modification: ce que vous avez fait / rajoute\u00e9 Les types de modification peuvent \u00eatre : - correction - x64 - arm - misc (on y compte par exemple les ports COM, les syst\u00e8mes de fichiers ou tout autre chose qui ne rentre pas dans les cat\u00e9gories d'architecture) - exemple (ajout d'exemple) - autre (pour autre chose qui n'y entre pas) Il est recommand\u00e9 de ne pas faire plus d'un Commit par Pull Resquest. Marche \u00e0 suivre pour les exemples Suivez la structure des documents Appliquez-vous sur votre code (lisibilit\u00e9, commentaires, v\u00e9rification) N'importe quel langage peut \u00eatre utilis\u00e9 R\u00e9dig\u00e9 par @Supercip971, contribution par @busybox11","title":"Contribuer au wiki"},{"location":"CONTRIBUER/#contribuer-au-wiki","text":"","title":"Contribuer au wiki"},{"location":"CONTRIBUER/#avant-toute-contribution-la-lecture-de-ce-domument-est-obligatoire","text":"Evitez de faire des fautes d'orthographes. Nous utilisons comme langage principal le C ou le C++. Merci de ne pas copier-coller d'autres articles. Nous refusons le 32bit car ce n'est plus d'actualit\u00e9.","title":"Avant toute contribution, la lecture de ce domument est obligatoire."},{"location":"CONTRIBUER/#la-structure-suivante-est-de-rigueur-pour-lensemble-des-documents","text":"En haut du document, vous retrouvez des liens / une table qui regroupe toute les parties du document, Vous retrouverez ensuite si n\u00e9c\u00e9ssaire les parties \u00e0 configurer, Vous retrouverez pour finir le contenu du document. A la fin, vous devez rajouter votre pseudo github comme ceci : ### R\u00e9gid\u00e9 par [pseudo du cr\u00e9ateur], contribution.s par [pseudos des contributeurs]","title":"La structure suivante est de rigueur pour l'ensemble des documents :"},{"location":"CONTRIBUER/#commits-pull-requests","text":"Vous devez suivre les r\u00e8gles suivantes pour la r\u00e9daction des noms de commits / pull requests.","title":"Commits / Pull requests"},{"location":"CONTRIBUER/#type-de-la-modification-ce-que-vous-avez-fait-rajoutee","text":"Les types de modification peuvent \u00eatre : - correction - x64 - arm - misc (on y compte par exemple les ports COM, les syst\u00e8mes de fichiers ou tout autre chose qui ne rentre pas dans les cat\u00e9gories d'architecture) - exemple (ajout d'exemple) - autre (pour autre chose qui n'y entre pas) Il est recommand\u00e9 de ne pas faire plus d'un Commit par Pull Resquest.","title":"type de la modification: ce que vous avez fait / rajoute\u00e9"},{"location":"CONTRIBUER/#marche-a-suivre-pour-les-exemples","text":"Suivez la structure des documents Appliquez-vous sur votre code (lisibilit\u00e9, commentaires, v\u00e9rification) N'importe quel langage peut \u00eatre utilis\u00e9","title":"Marche \u00e0 suivre pour les exemples"},{"location":"CONTRIBUER/#redige-par-supercip971-contribution-par-busybox11","text":"","title":"R\u00e9dig\u00e9 par @Supercip971, contribution par @busybox11"},{"location":"meta/template/","text":"Article title Introduction Resources Editors","title":"Article title"},{"location":"meta/template/#article-title","text":"","title":"Article title"},{"location":"meta/template/#introduction","text":"","title":"Introduction"},{"location":"meta/template/#resources","text":"","title":"Resources"},{"location":"meta/template/#editors","text":"","title":"Editors"},{"location":"x86_64/Devices/APIC/","text":"Advanced Programmable Interrupt Controller","title":"Advanced Programmable Interrupt Controller"},{"location":"x86_64/Devices/APIC/#advanced-programmable-interrupt-controller","text":"","title":"Advanced Programmable Interrupt Controller"},{"location":"x86_64/Devices/COM/","text":"Warning! This article is in progress. Introduction The COM port was commonly used as a hardware communication interface. The COM port has been out of use for many years in favor of better alternitives such as USB. Although they are obsolete, COM ports are still widely used for operating system development. They are very simple to implement and are very useful for debugging because it allows you to log debug information to the terminal or file on the host machine. They are also very useful because they can be initialized very early and therefore have debugging information efficiently. For example, serial ports can send data and receive data, which would make it possible to make an external terminal using only that port. RS-232 (which has been revised over and over again) is a standard that standardizes serial ports. Initally created in 1981, it standardizes names (COM1, COM2, COM3, etc.) and limits the speed to 19200 Baud, which is more than enough for a small terminal (therefore potentially 19200 characters per second). The limit being calculated in Baud, this being expressed in bit / s, 1 baud therefore corresponds to 1 bit per second. The limit also depends on the distance of the connection with the wire, a long wire has a lower capacity than a short wire. Initialization Each port needs to be initialized before use. To start with, there are a few constant values \u200b\u200bto know for each COM port. COM port Port Id IRQ COM1 0x3F8 4 COM2 0x2F8 3 COM3 0x3E8 4 COM4 0x2E8 3 To initalize a COM port we must set some offsets. Each offset has a certain action. (= PORT ID + OFFSET) offset action 0 The Data port of the COM, it is used to send and receive data, if the DLAB bit = 1 then it is to put the Baud divider (the lower bits) 1 The Interrupt port of the COM, it is used to activate the Interrupt of the port, if the DLAB bit = 1 then it is to put the value of the divider (of the Baud also but for the higher bits) 2 The interrupt identifier or the FIFO controller 3 the line control (The highest bit is the one for DLAB) 4 Modem control 5 The status of the line 6 The status of Modem 7 The scratch register To enable the DLAB you must put the port as indicated: PORT + 3 = 0x80 = 128 = 0b10000000 outb(COM_PORT + 3, 0x80); To deactivate it, you just have to reset bit 8 to 0. Baud Rate The COM port updates 115,200 times per second. To control the speed, it is necessary to set up a divider, which can be used by activating the DLAB. Then, the value must be passed through the offset 0 (the lower bits) and 1 (the upper bits). Example allowing to put a divisor of 5 (then the port will have a 'rate' of 115200/5): outb (COM_PORT + 3, 0x80); // activate DLAB outb (COM_PORT + 0, 5); // the smallest bits outb (COM_PORT + 1, 0); // the highest bits Data size You can set the size of the data sent to the COM port. This can range from 5 bits to 8 bits 5bits = 0 0 (0x0) 6bits = 0 1 (0x1) 7bits = 1 0 (0x2) 8bits = 1 1 (0x3) To define the size of the data, you must write it to the line control port (the smallest bits) having configured the port rate (and therefore having enabled the DLAB). outb(COM_PORT + 3, 0x3); // disable DLAB + put the data size to 8, the size of a char / unsigned char in c++ Resources https://www.sci.muni.cz/docs/pc/serport.txt Written by @Supercip971, contribution by @busybox11","title":"COM"},{"location":"x86_64/Devices/COM/#introduction","text":"The COM port was commonly used as a hardware communication interface. The COM port has been out of use for many years in favor of better alternitives such as USB. Although they are obsolete, COM ports are still widely used for operating system development. They are very simple to implement and are very useful for debugging because it allows you to log debug information to the terminal or file on the host machine. They are also very useful because they can be initialized very early and therefore have debugging information efficiently. For example, serial ports can send data and receive data, which would make it possible to make an external terminal using only that port. RS-232 (which has been revised over and over again) is a standard that standardizes serial ports. Initally created in 1981, it standardizes names (COM1, COM2, COM3, etc.) and limits the speed to 19200 Baud, which is more than enough for a small terminal (therefore potentially 19200 characters per second). The limit being calculated in Baud, this being expressed in bit / s, 1 baud therefore corresponds to 1 bit per second. The limit also depends on the distance of the connection with the wire, a long wire has a lower capacity than a short wire.","title":"Introduction"},{"location":"x86_64/Devices/COM/#initialization","text":"Each port needs to be initialized before use. To start with, there are a few constant values \u200b\u200bto know for each COM port. COM port Port Id IRQ COM1 0x3F8 4 COM2 0x2F8 3 COM3 0x3E8 4 COM4 0x2E8 3 To initalize a COM port we must set some offsets. Each offset has a certain action. (= PORT ID + OFFSET) offset action 0 The Data port of the COM, it is used to send and receive data, if the DLAB bit = 1 then it is to put the Baud divider (the lower bits) 1 The Interrupt port of the COM, it is used to activate the Interrupt of the port, if the DLAB bit = 1 then it is to put the value of the divider (of the Baud also but for the higher bits) 2 The interrupt identifier or the FIFO controller 3 the line control (The highest bit is the one for DLAB) 4 Modem control 5 The status of the line 6 The status of Modem 7 The scratch register To enable the DLAB you must put the port as indicated: PORT + 3 = 0x80 = 128 = 0b10000000 outb(COM_PORT + 3, 0x80); To deactivate it, you just have to reset bit 8 to 0.","title":"Initialization"},{"location":"x86_64/Devices/COM/#baud-rate","text":"The COM port updates 115,200 times per second. To control the speed, it is necessary to set up a divider, which can be used by activating the DLAB. Then, the value must be passed through the offset 0 (the lower bits) and 1 (the upper bits). Example allowing to put a divisor of 5 (then the port will have a 'rate' of 115200/5): outb (COM_PORT + 3, 0x80); // activate DLAB outb (COM_PORT + 0, 5); // the smallest bits outb (COM_PORT + 1, 0); // the highest bits","title":"Baud Rate"},{"location":"x86_64/Devices/COM/#data-size","text":"You can set the size of the data sent to the COM port. This can range from 5 bits to 8 bits 5bits = 0 0 (0x0) 6bits = 0 1 (0x1) 7bits = 1 0 (0x2) 8bits = 1 1 (0x3) To define the size of the data, you must write it to the line control port (the smallest bits) having configured the port rate (and therefore having enabled the DLAB). outb(COM_PORT + 3, 0x3); // disable DLAB + put the data size to 8, the size of a char / unsigned char in c++","title":"Data size"},{"location":"x86_64/Devices/COM/#resources","text":"https://www.sci.muni.cz/docs/pc/serport.txt","title":"Resources"},{"location":"x86_64/Devices/COM/#written-by-supercip971-contribution-by-busybox11","text":"","title":"Written by @Supercip971, contribution by @busybox11"},{"location":"x86_64/Devices/LAPIC/","text":"Local APIC The local APIC is an entry of the MADT , its type is 0 The number of local APIC entries in the MADT is equivalent to the number of CPUs, each cpu has its local APIC the structure of the APIC room entrance is offset / size (in bytes) name 2/1 ACPI identifier 3/1 APIC identifier 4/4 cpu flag","title":"Local APIC"},{"location":"x86_64/Devices/LAPIC/#local-apic","text":"The local APIC is an entry of the MADT , its type is 0 The number of local APIC entries in the MADT is equivalent to the number of CPUs, each cpu has its local APIC the structure of the APIC room entrance is offset / size (in bytes) name 2/1 ACPI identifier 3/1 APIC identifier 4/4 cpu flag","title":"Local APIC"},{"location":"x86_64/Devices/MADT/","text":"Multiple APIC Description Table","title":"Multiple APIC Description Table"},{"location":"x86_64/Devices/MADT/#multiple-apic-description-table","text":"","title":"Multiple APIC Description Table"},{"location":"x86_64/Devices/PIC/","text":"","title":"PIC"},{"location":"x86_64/Devices/PIT/","text":"","title":"PIT"},{"location":"x86_64/Structures/GDT/","text":"Global Descriptor Table","title":"Global Descriptor Table"},{"location":"x86_64/Structures/GDT/#global-descriptor-table","text":"","title":"Global Descriptor Table"},{"location":"x86_64/Structures/IDT/","text":"Interrupt Descriptor Table","title":"Interrupt Descriptor Table"},{"location":"x86_64/Structures/IDT/#interrupt-descriptor-table","text":"","title":"Interrupt Descriptor Table"},{"location":"x86_64/Tutorials/First%20steps/00-Introduction/","text":"","title":"00 Introduction"},{"location":"x86_64/Tutorials/First%20steps/01-Hello%2C%20World%21/","text":"","title":"01 Hello, World!"},{"location":"x86_64/Tutorials/First%20steps/02-Segmentation/","text":"","title":"02 Segmentation"},{"location":"x86_64/Tutorials/First%20steps/03-Interuption/","text":"","title":"03 Interuption"},{"location":"x86_64/Tutorials/First%20steps/04-Memoire/","text":"","title":"04 Memoire"},{"location":"x86_64/Tutorials/First%20steps/05-Pagination/","text":"","title":"05 Pagination"},{"location":"x86_64/Tutorials/First%20steps/06-Multit%C3%A2che/","text":"","title":"06 Multit\u00e2che"},{"location":"x86_64/Tutorials/First%20steps/07-T%C3%A2che%20Utilisateur/","text":"","title":"07 T\u00e2che Utilisateur"},{"location":"x86_64/Tutorials/First%20steps/08-Epilogue/","text":"","title":"08 Epilogue"},{"location":"x86_64/Tutorials/SMP/SMP/","text":"Symmetric Multi Processing Introduction What is SMP? The SMP stands for symmetric multi processing We use this term to mean multi processor. A kernel that supports SMP can have a huge performance boost. Knowing that generally processors have 2 threads per cpu, for an 8 core processor we have 16 exploitable threads. The SMP is different from NUMA, the NUMA processors are processors where some cores do not have access to all of the memory. In this tutorial to implement the smp we take into account that you have already implemented in your kernel: IDT GDT MADT LAPIC APIC paging Your kernel is higher half Your kernel is 64-bit A timer system You will be necessary to implement the interrupt [APIC] (devse-documentation-en/x86_64/Devices/APIC) for the other CPUs, which is not covered in this tutorial (for now) Get Current CPU Number Obtaining the current CPU number will be very important for later. to obtain the identifier number of the current CPU we must use the APIC we must read in the apic at register 20 then we must shift the bits to 24 // LAPIC_REGISTER = 20 uint32_t get_current_processor_id() { return apic::read(LAPIC_REGISTER) >> 24; } Obtain the Local APIC Entries see: LAPIC To start the SMP you have to get the LAPIC entries from the MADT table Each cpu has a LAPIC entry. The number of cpu is therefore the number of LAPICs in the MADT. LAPIC input 2 is important ACPI_ID : used for acpi and APIC_ID : used for APIC, during initialization usually ACPI_ID and APIC_ID are equal it must be taken into account that the main cpu (the one that is booted at startup) is also in the list. We must then separate this entry by comparing if the number of the current cpu is equal to the cpu number of the local APIC entry if(get_current_processor_id() == lapic_entry.apic_id) { // then it's the main cpu } else { // a cpu that we can use! } Pre-Initialization Before initializing the cpu, the ground must be prepared. You have to prepare where you will place the IDT/page tables/GDT/ initialization code of your cpu we will place everything like this: entry address trampoline code 0x1000 stack 0x570 gdt 0x580 idt 0x590 table page 0x600 jump address 0x610 You should know that it will later change the FDT and the page table, all this is temporary and must be replaced, the stack, the GDT, and the page table. GDT + IDT To store the GDT and the IDT is simple we can just use 64-bit instructions sgdt sidt These instructions allow to store the GDT and the IDT in a precise address. so sgdt [0x580] ; GDT storage sidt [0x590] ; IDT storage Stack for the stack we must store a valid address at 0x570 POKE(570) = stack_address + stack_size; Trampoline Code For the trampoline code you need assembly code delimited by __trampoline_start and __trampoline_end You will have to copy the trampline code from 0x1000 to the size of the trampoline. donc // knowing that TRAMPOLINE_START == 0x1000 uint64_t trampoline_len = (uint64_t)&trampoline_end - (uint64_t)&trampoline_start; memcpy((void *)TRAMPOLINE_START, &trampoline_start, trampoline_len); and in the assembly code: trampoline_start: ; trampoline code trampoline_end: Jump address The jump address is the function that the cpu will call after its initialization Page table for the future CPUs The page table can be a copy of the current CPU page table but if it is a copy then after the initialization of the cpu try to give a copy and not keep the current table. after having done all this we can go to the initialization of the CPU Loading the CPU avant il faut demander \u00e0 l'apic de charger le cpu il faut faire \u00e9crire au 2 registre de commande d'interruption (aussi appel\u00e9 ICR) il faut \u00e9crire au ICR1 (aka registre 0x300) 0b10100000000 (0x500) cela veut dire d'envoyer l'interruption d'initialisation au cpu dans ICR2 il faut \u00e9crire au ICR2 l'id du processeur shifter de 24 on a donc write(icr2, (apic_id << 24)); write(icr1, 0x500); ensuite il faut attendre 10 ms pour que le cpu s'initialise on doit ensuite envoyer \u00e0 l'apic l'addresse du trampoline pour demander au cpu d'aller en 0x1000 il faut envoyer comme la premi\u00e8re \u00e9tape le apic_id (apic_id << 24) mais il faut envoyer \u00e0 l'icr1 le bit 11 et 10 pour demander aux cpu de charger la page envoy\u00e9 du trampoline donc (0x600) write(icr2, (apic_id << 24)); write(icr1, 0x600 | ((uint32_t)trampoline_addr / 4096)); maintenant vous pouvez commencer \u00e0 coder le code du trampoline ! Le Code Du Trampoline note: pour d\u00e9bugger vous pouvez utiliser ce code mov al, 'a' mov dx, 0x3F8 out dx, al le code output le charact\u00e8re a dans le port com0 c'est utile temporairement pour debugger, c'est la solution la plus courte est simple. Bien s\u00fbr le code est temporaire pour le trampoline il faut savoir que le cpu est initialis\u00e9 en 16bit, il faut donc le passer comme ceci 16bit => 32bit => 64bit on doit donc faire comme ceci [bits 16] trampoline_start: trampoline_16: ;... [bits 32] trampoline_32: ;... [bits 64] trampoline_64: ;... trampoline_end: Le Code 16-Bits pour passer de 16bit \u00e0 32bit il faut initialiser une gdt et mettre le bit 0 du cr0 \u00e0 1 pour activer le protected mode cli ; d\u00e9sactiver les interrupt mov ax, 0x0 ; mettre tout \u00e0 0 mov ds, ax mov es, ax mov fs, ax mov gs, ax mov ss, ax pour le chargement de la gdt il faut que avant le trampoline_end il y ait une structure de gdt pour le 16bit il faut alors : align 16 gdt_16: dw gdt_16_end - gdt_16_start - 1 dd gdt_16_start - trampoline_start + TRAMPOLINE_BASE align 16 gdt_16_start: ; null selector 0x0 dq 0 ; cs selector 8 dq 0x00CF9A000000FFFF ; ds selector 16 dq 0x00CF92000000FFFF gdt_16_end: et dans le code on peut faire lgdt [gdt_16 - trampoline_start + TRAMPOLINE_BASE] il faut ensuite faire mov eax, cr0 or al, 0x1 mov cr0, eax et pour finir on peut jump dans le code 32bit jmp 0x8:(trampoline32 - trampoline_start + TRAMPOLINE_BASE) le jmp 0x8:... permet de dire de loader le segment de code de la gdt Le Code 32 Bits il faut commencer par charger la table de page dans le cr3 mov eax, dword [0x600] mov cr3, eax et ensuite activer le paging, et le PAE du cr4 en mettant les bit 5 et 7 du registre cr4 mov eax, cr4 or eax, 1 << 5 or eax, 1 << 7 mov cr4, eax il faut ensuite activer le long mode en \u00e9crivant le bit 8 du MSR de l'EFER (L'extended Feature Enable Register) mov ecx, 0xc0000080 ; registre efer rdmsr or eax,1 << 8 wrmsr il faut, ensuite activer le paging dans le registre cr0 en activant le bit 31 mov eax, cr0 or eax, 1 << 31 mov cr0, eax pour finir on doit charger une gdt 64bit Il faut donc avoir une structure gdt avant le trampoline end align 16 gdt_64: dw gdt_64_end - gdt_64_start - 1 dd gdt_64_start - trampoline_start + TRAMPOLINE_BASE align 16 gdt_64_start: ; null selector 0x0 dq 0 ; cs selector 8 dq 0x00AF98000000FFFF ; ds selector 16 dq 0x00CF92000000FFFF gdt_64_end: et donc charget la gdt lgdt [gdt_64 - trampoline_start + TRAMPOLINE_BASE] et pour passer au 64bit on doit jump comme ceci jmp 8:(trampoline64 - trampoline_start + TRAMPOLINE_BASE) ceci met le code segment \u00e0 8 Le Code 64 Bits en 64 bit il faut setup les registres ds/ss/es/ par rapport \u00e0 votre gdt mov ax, 0x10 mov ds, ax mov es, ax mov ss, ax mov ax, 0x0 mov fs, ax mov gs, ax il faut ensuite charger la gdt/ et l'idt par rapport au addresse de stockage utilis\u00e9 lgdt [0x580] lidt [0x590] on doit aussi charger la stack mov rsp, [0x570] mov rbp, 0x0 on doit ensuite passer du code copi\u00e9 du trempoline au code physique donc on doit faire jmp virtual_code virtual_code: dans le virtual code on doit activer certains bit de cr4 et cr0 si vous voulez le sse, vous devez l'activer ici il faut donc activer le bit 1 et d\u00e9sactiver le 2 du registre cr0 pour le monitoring du multi processor et l'\u00e9mulation mov rax, cr0 btr eax, 2 bts eax, 1 mov cr0, rax il faut pour terminer l'initialisation du smp faire mov rax, [0x610] jmp rax maintenant vous avez un cpu d'initialis\u00e9 ! Derni\u00e8re Pens\u00e9e mais il reste encore beaucoup de chose \u00e0 faire ! un syst\u00e8me de lock, mettre \u00e0 jour le multitasking, initialiser les cpu avec une gdt/idt/... unique etc... Ressources manuel intel osdev","title":"Symmetric Multi Processing"},{"location":"x86_64/Tutorials/SMP/SMP/#symmetric-multi-processing","text":"","title":"Symmetric Multi Processing"},{"location":"x86_64/Tutorials/SMP/SMP/#introduction","text":"What is SMP? The SMP stands for symmetric multi processing We use this term to mean multi processor. A kernel that supports SMP can have a huge performance boost. Knowing that generally processors have 2 threads per cpu, for an 8 core processor we have 16 exploitable threads. The SMP is different from NUMA, the NUMA processors are processors where some cores do not have access to all of the memory. In this tutorial to implement the smp we take into account that you have already implemented in your kernel: IDT GDT MADT LAPIC APIC paging Your kernel is higher half Your kernel is 64-bit A timer system You will be necessary to implement the interrupt [APIC] (devse-documentation-en/x86_64/Devices/APIC) for the other CPUs, which is not covered in this tutorial (for now)","title":"Introduction"},{"location":"x86_64/Tutorials/SMP/SMP/#get-current-cpu-number","text":"Obtaining the current CPU number will be very important for later. to obtain the identifier number of the current CPU we must use the APIC we must read in the apic at register 20 then we must shift the bits to 24 // LAPIC_REGISTER = 20 uint32_t get_current_processor_id() { return apic::read(LAPIC_REGISTER) >> 24; }","title":"Get Current CPU Number"},{"location":"x86_64/Tutorials/SMP/SMP/#obtain-the-local-apic-entries","text":"see: LAPIC To start the SMP you have to get the LAPIC entries from the MADT table Each cpu has a LAPIC entry. The number of cpu is therefore the number of LAPICs in the MADT. LAPIC input 2 is important ACPI_ID : used for acpi and APIC_ID : used for APIC, during initialization usually ACPI_ID and APIC_ID are equal it must be taken into account that the main cpu (the one that is booted at startup) is also in the list. We must then separate this entry by comparing if the number of the current cpu is equal to the cpu number of the local APIC entry if(get_current_processor_id() == lapic_entry.apic_id) { // then it's the main cpu } else { // a cpu that we can use! }","title":"Obtain the Local APIC Entries"},{"location":"x86_64/Tutorials/SMP/SMP/#pre-initialization","text":"Before initializing the cpu, the ground must be prepared. You have to prepare where you will place the IDT/page tables/GDT/ initialization code of your cpu we will place everything like this: entry address trampoline code 0x1000 stack 0x570 gdt 0x580 idt 0x590 table page 0x600 jump address 0x610 You should know that it will later change the FDT and the page table, all this is temporary and must be replaced, the stack, the GDT, and the page table.","title":"Pre-Initialization"},{"location":"x86_64/Tutorials/SMP/SMP/#gdt-idt","text":"To store the GDT and the IDT is simple we can just use 64-bit instructions sgdt sidt These instructions allow to store the GDT and the IDT in a precise address. so sgdt [0x580] ; GDT storage sidt [0x590] ; IDT storage","title":"GDT + IDT"},{"location":"x86_64/Tutorials/SMP/SMP/#stack","text":"for the stack we must store a valid address at 0x570 POKE(570) = stack_address + stack_size;","title":"Stack"},{"location":"x86_64/Tutorials/SMP/SMP/#trampoline-code","text":"For the trampoline code you need assembly code delimited by __trampoline_start and __trampoline_end You will have to copy the trampline code from 0x1000 to the size of the trampoline. donc // knowing that TRAMPOLINE_START == 0x1000 uint64_t trampoline_len = (uint64_t)&trampoline_end - (uint64_t)&trampoline_start; memcpy((void *)TRAMPOLINE_START, &trampoline_start, trampoline_len); and in the assembly code: trampoline_start: ; trampoline code trampoline_end:","title":"Trampoline Code"},{"location":"x86_64/Tutorials/SMP/SMP/#jump-address","text":"The jump address is the function that the cpu will call after its initialization","title":"Jump address"},{"location":"x86_64/Tutorials/SMP/SMP/#page-table-for-the-future-cpus","text":"The page table can be a copy of the current CPU page table but if it is a copy then after the initialization of the cpu try to give a copy and not keep the current table. after having done all this we can go to the initialization of the CPU","title":"Page table for the future CPUs"},{"location":"x86_64/Tutorials/SMP/SMP/#loading-the-cpu","text":"avant il faut demander \u00e0 l'apic de charger le cpu il faut faire \u00e9crire au 2 registre de commande d'interruption (aussi appel\u00e9 ICR) il faut \u00e9crire au ICR1 (aka registre 0x300) 0b10100000000 (0x500) cela veut dire d'envoyer l'interruption d'initialisation au cpu dans ICR2 il faut \u00e9crire au ICR2 l'id du processeur shifter de 24 on a donc write(icr2, (apic_id << 24)); write(icr1, 0x500); ensuite il faut attendre 10 ms pour que le cpu s'initialise on doit ensuite envoyer \u00e0 l'apic l'addresse du trampoline pour demander au cpu d'aller en 0x1000 il faut envoyer comme la premi\u00e8re \u00e9tape le apic_id (apic_id << 24) mais il faut envoyer \u00e0 l'icr1 le bit 11 et 10 pour demander aux cpu de charger la page envoy\u00e9 du trampoline donc (0x600) write(icr2, (apic_id << 24)); write(icr1, 0x600 | ((uint32_t)trampoline_addr / 4096)); maintenant vous pouvez commencer \u00e0 coder le code du trampoline !","title":"Loading the CPU"},{"location":"x86_64/Tutorials/SMP/SMP/#le-code-du-trampoline","text":"note: pour d\u00e9bugger vous pouvez utiliser ce code mov al, 'a' mov dx, 0x3F8 out dx, al le code output le charact\u00e8re a dans le port com0 c'est utile temporairement pour debugger, c'est la solution la plus courte est simple. Bien s\u00fbr le code est temporaire pour le trampoline il faut savoir que le cpu est initialis\u00e9 en 16bit, il faut donc le passer comme ceci 16bit => 32bit => 64bit on doit donc faire comme ceci [bits 16] trampoline_start: trampoline_16: ;... [bits 32] trampoline_32: ;... [bits 64] trampoline_64: ;... trampoline_end:","title":"Le Code Du Trampoline"},{"location":"x86_64/Tutorials/SMP/SMP/#le-code-16-bits","text":"pour passer de 16bit \u00e0 32bit il faut initialiser une gdt et mettre le bit 0 du cr0 \u00e0 1 pour activer le protected mode cli ; d\u00e9sactiver les interrupt mov ax, 0x0 ; mettre tout \u00e0 0 mov ds, ax mov es, ax mov fs, ax mov gs, ax mov ss, ax pour le chargement de la gdt il faut que avant le trampoline_end il y ait une structure de gdt pour le 16bit il faut alors : align 16 gdt_16: dw gdt_16_end - gdt_16_start - 1 dd gdt_16_start - trampoline_start + TRAMPOLINE_BASE align 16 gdt_16_start: ; null selector 0x0 dq 0 ; cs selector 8 dq 0x00CF9A000000FFFF ; ds selector 16 dq 0x00CF92000000FFFF gdt_16_end: et dans le code on peut faire lgdt [gdt_16 - trampoline_start + TRAMPOLINE_BASE] il faut ensuite faire mov eax, cr0 or al, 0x1 mov cr0, eax et pour finir on peut jump dans le code 32bit jmp 0x8:(trampoline32 - trampoline_start + TRAMPOLINE_BASE) le jmp 0x8:... permet de dire de loader le segment de code de la gdt","title":"Le Code 16-Bits"},{"location":"x86_64/Tutorials/SMP/SMP/#le-code-32-bits","text":"il faut commencer par charger la table de page dans le cr3 mov eax, dword [0x600] mov cr3, eax et ensuite activer le paging, et le PAE du cr4 en mettant les bit 5 et 7 du registre cr4 mov eax, cr4 or eax, 1 << 5 or eax, 1 << 7 mov cr4, eax il faut ensuite activer le long mode en \u00e9crivant le bit 8 du MSR de l'EFER (L'extended Feature Enable Register) mov ecx, 0xc0000080 ; registre efer rdmsr or eax,1 << 8 wrmsr il faut, ensuite activer le paging dans le registre cr0 en activant le bit 31 mov eax, cr0 or eax, 1 << 31 mov cr0, eax pour finir on doit charger une gdt 64bit Il faut donc avoir une structure gdt avant le trampoline end align 16 gdt_64: dw gdt_64_end - gdt_64_start - 1 dd gdt_64_start - trampoline_start + TRAMPOLINE_BASE align 16 gdt_64_start: ; null selector 0x0 dq 0 ; cs selector 8 dq 0x00AF98000000FFFF ; ds selector 16 dq 0x00CF92000000FFFF gdt_64_end: et donc charget la gdt lgdt [gdt_64 - trampoline_start + TRAMPOLINE_BASE] et pour passer au 64bit on doit jump comme ceci jmp 8:(trampoline64 - trampoline_start + TRAMPOLINE_BASE) ceci met le code segment \u00e0 8","title":"Le Code 32 Bits"},{"location":"x86_64/Tutorials/SMP/SMP/#le-code-64-bits","text":"en 64 bit il faut setup les registres ds/ss/es/ par rapport \u00e0 votre gdt mov ax, 0x10 mov ds, ax mov es, ax mov ss, ax mov ax, 0x0 mov fs, ax mov gs, ax il faut ensuite charger la gdt/ et l'idt par rapport au addresse de stockage utilis\u00e9 lgdt [0x580] lidt [0x590] on doit aussi charger la stack mov rsp, [0x570] mov rbp, 0x0 on doit ensuite passer du code copi\u00e9 du trempoline au code physique donc on doit faire jmp virtual_code virtual_code: dans le virtual code on doit activer certains bit de cr4 et cr0 si vous voulez le sse, vous devez l'activer ici il faut donc activer le bit 1 et d\u00e9sactiver le 2 du registre cr0 pour le monitoring du multi processor et l'\u00e9mulation mov rax, cr0 btr eax, 2 bts eax, 1 mov cr0, rax il faut pour terminer l'initialisation du smp faire mov rax, [0x610] jmp rax maintenant vous avez un cpu d'initialis\u00e9 !","title":"Le Code 64 Bits"},{"location":"x86_64/Tutorials/SMP/SMP/#derniere-pensee","text":"mais il reste encore beaucoup de chose \u00e0 faire ! un syst\u00e8me de lock, mettre \u00e0 jour le multitasking, initialiser les cpu avec une gdt/idt/... unique etc...","title":"Derni\u00e8re Pens\u00e9e"},{"location":"x86_64/Tutorials/SMP/SMP/#ressources","text":"manuel intel osdev","title":"Ressources"}]}